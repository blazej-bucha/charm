
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>CHarm &#8212; CHarm 0.4.6-dev documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="_static/css/custom_BB.css" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="_static/documentation_options.js?v=ca51ea35"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'cookbook-c';</script>
    <link rel="icon" href="_static/charm-logo-favicon.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PyHarm" href="cookbook-py.html" />
    <link rel="prev" title="Cookbook" href="cookbook.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="0.4.6-dev" />
    <meta name="docbuild:last-update" content="Jul 18, 2025"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/charm-logo.png" class="logo__image only-light" alt=""/>
    <img src="_static/charm-logo.png" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">CHarm v0.4.6-dev</p>
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="install.html">Installing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="install-pyharm-pip.html">Installation of PyHarm with pip</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="build-from-src.html">Building from source</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="build-from-src-unix.html">Unix-based operating systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-from-src-non-unix.html">Windows 10 and later</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="definitions.html">Some definitions to make things clear</a></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="cookbook.html">Cookbook</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">CHarm</a></li>
<li class="toctree-l2"><a class="reference internal" href="cookbook-py.html">PyHarm</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="api.html">Interfaces</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="api-c.html">CHarm (C API)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="api-c-shc.html">charm_shc</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-crd.html">charm_crd</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-shs.html">charm_shs</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-sha.html">charm_sha</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-gfm.html">charm_gfm</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-leg.html">charm_leg</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-integ.html">charm_integ</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-misc.html">charm_misc</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-err.html">charm_err</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-mpi.html">charm_mpi</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-glob.html">charm_glob</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-c-charm.html">charm</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="api-py.html">PyHarm (Python API)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="api-py-shc.html">pyharm.shc</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-py-crd.html">pyharm.crd</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-py-shs.html">pyharm.shs</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-py-sha.html">pyharm.sha</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-py-gfm.html">pyharm.gfm</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-py-leg.html">pyharm.leg</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-py-integ.html">pyharm.integ</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-py-misc.html">pyharm.misc</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-py-glob.html">pyharm.glob</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">Tested platforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Acknowledgements</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/blazej-bucha/charm" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/blazej-bucha/charm/edit/master/docs/src/cookbook-c.rst" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/blazej-bucha/charm/issues/new?title=Issue%20on%20page%20%2Fcookbook-c.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/cookbook-c.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>CHarm</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#charm-in-double-precision">CHarm in double precision</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compilation-on-linux">Compilation on Linux</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#working-with-spherical-harmonic-coefficients">Working with spherical harmonic coefficients</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spherical-harmonic-synthesis-and-analysis">Spherical harmonic synthesis and analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#first-and-second-order-gradients-gravitational-vector-and-tensor">First- and second-order gradients (gravitational vector and tensor)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gravity-forward-modelling">Gravity forward modelling</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fourier-coefficients-of-legendre-functions">Fourier coefficients of Legendre functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#integrals">Integrals</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#distributed-computing-with-mpi">Distributed computing with MPI</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#charm-in-single-and-quadruple-precision">CHarm in single and quadruple precision</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-compilation-in-single-precision">Example compilation in single precision</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-compilation-in-quadruple-precision">Example compilation in quadruple precision</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="charm">
<span id="charm-cookbook"></span><h1>CHarm<a class="headerlink" href="#charm" title="Link to this heading">#</a></h1>
<p>This chapter demonstrates how to perform some basic tasks with
CHarm.  For a detailed description of the functions to be used, see the
<a class="reference internal" href="api-c.html#c-api"><span class="std std-ref">CHarm (C API)</span></a> chapter.  The source codes of the examples can be found in the
<code class="docutils literal notranslate"><span class="pre">cookbook/c</span></code> directory.</p>
<p>A single header file of the entire library is available as:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">charm/charmf.h</span></code> for single precision,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">charm/charm.h</span></code> for double precision, and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">charm/charmq.h</span></code> for quadruple precision.</p></li>
</ul>
<p>You may combine various precisions in a single program, provided that you
follow the rules from the <a class="reference internal" href="#charm-in-single-and-quad-precision"><span class="std std-ref">CHarm in single and quadruple precision</span></a> chapter
below.  It is not recommended though to combine various releases (e.g., single
precision from v0.0.0 and double precision form v0.1.0).</p>
<p>The chapters that follow show how to work with CHarm in double, single and
quadruple precision, respectively.</p>
<section id="charm-in-double-precision">
<h2>CHarm in double precision<a class="headerlink" href="#charm-in-double-precision" title="Link to this heading">#</a></h2>
<p>In this section, we assume you have successfully installed CHarm (see
<a class="reference internal" href="install.html#installing"><span class="std std-ref">Installing</span></a>) in double precision with OpenMP enabled into the default
installation paths, and that you know how to compile a C code and link external
libraries.  A brief example of the compilation under Linux with GCC is provided
in the <a class="reference internal" href="#compilation-linux"><span class="std std-ref">Compilation on Linux</span></a> section below.</p>
<section id="compilation-on-linux">
<span id="compilation-linux"></span><h3>Compilation on Linux<a class="headerlink" href="#compilation-on-linux" title="Link to this heading">#</a></h3>
<p>Assuming your working directory is <code class="docutils literal notranslate"><span class="pre">cookbook/c</span></code>, an example compilation
with the static library might look like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-fopenmp<span class="w"> </span>shcs.c<span class="w"> </span>-l:libcharm.a<span class="w"> </span>-lfftw3<span class="w"> </span>-lfftw3_omp<span class="w"> </span>-lm
</pre></div>
</div>
<p>Compilation using the shared library:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-fopenmp<span class="w"> </span>-Wl,-rpath<span class="w"> </span>-Wl,/usr/local/lib<span class="w"> </span>shcs.c<span class="w"> </span><span class="se">\</span>
<span class="w">     </span>-lcharm<span class="w"> </span>-lfftw3<span class="w"> </span>-lfftw3_omp<span class="w"> </span>-lm
</pre></div>
</div>
<p>After a successful compilation, you are ready to execute the compiled binary as</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>./a.out
</pre></div>
</div>
<p>You should see the following output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>C(  9,  0) = 2.7671430085300001e-08
S(  9,  0) = 0.0000000000000000e+00
C(  9,  4) = -9.0017922533600003e-09
S(  9,  4) = 1.9466677947499999e-08
C(  9,  9) = -4.7747538613200003e-08
S(  9,  9) = 9.6641284771399995e-08


Degree variance for harmonic degree 0 = 1.0000000000000000e+00
Degree variance for harmonic degree 4 = 2.5183167531865940e-12
Degree variance for harmonic degree 10 = 1.2631494966213168e-13


Difference degree variance for harmonic degree 0 = 0.0000000000000000e+00
Difference degree variance for harmonic degree 4 = 0.0000000000000000e+00
Difference degree variance for harmonic degree 10 = 0.0000000000000000e+00

Great, all done!
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Various approaches exist to compile the code using static/shared libraries.
Use whatever works best for you.</p>
</div>
</section>
<section id="working-with-spherical-harmonic-coefficients">
<h3>Working with spherical harmonic coefficients<a class="headerlink" href="#working-with-spherical-harmonic-coefficients" title="Link to this heading">#</a></h3>
<p>This example shows how to read/write spherical harmonic coefficients from/to
files and how to compute (difference) degree variances.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;charm/charm.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* INPUTS */</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="cm">/* Define the path to an input &quot;gfc&quot; text file with spherical harmonic</span>
<span class="cm">     * coefficients.  For details on the structure of the &quot;gfc&quot; file, see the</span>
<span class="cm">     * description of the &quot;charm_shc_read_gfc&quot; function in the &quot;charm_shc&quot;</span>
<span class="cm">     * module. */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">shcs_in_file</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../../data/input/EGM96-degree10.gfc&quot;</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Maximum harmonic degree to initialize, read and write spherical harmonic</span>
<span class="cm">     * coefficients */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Define the path to an output binary file with spherical harmonic</span>
<span class="cm">     * coefficients.  For details on the structure of the output binary file,</span>
<span class="cm">     * see the description of the &quot;charm_shc_write_bin&quot; function in the</span>
<span class="cm">     * &quot;charm_shc&quot; module. */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">shcs_out_file</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../../data/output/EGM96-degree10.shcs&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="cm">/* Read the spherical harmonic coefficients */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Initialize a &quot;charm_shc&quot; structure up to degree &quot;nmax&quot;.  All</span>
<span class="cm">     * coefficients will be initialized to zero and both the scaling constant</span>
<span class="cm">     * &quot;shcs-&gt;mu&quot; and the radius of the reference sphere &quot;shcs-&gt;r&quot; will be set</span>
<span class="cm">     * to &quot;1.0&quot;.  These values will later be overwritten when reading the input</span>
<span class="cm">     * file.  In case of failure, returned is &quot;NULL&quot;, so always check the</span>
<span class="cm">     * returned pointer for the &quot;NULL&quot; value! */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">shcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_calloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shcs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_shc</span><span class="se">\&quot;</span><span class="s"> structure&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Many CHarm functions take a &quot;charm_err&quot; structure as their last</span>
<span class="cm">     * parameter.  This is to allow the called function to report an error (if</span>
<span class="cm">     * encountered) back to the caller, including some useful information, such</span>
<span class="cm">     * as the error message, error code, function name and so on.  The error</span>
<span class="cm">     * structure is defined in the &quot;charm_err&quot; module and can be initialized</span>
<span class="cm">     * like this: */</span>
<span class="w">    </span><span class="n">charm_err</span><span class="w"> </span><span class="o">*</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_err_init</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_err</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Now let&#39;s read spherical harmonic coefficients, the scaling constant and</span>
<span class="cm">     * the radius of the reference sphere from the input &quot;gfc&quot; file.  We are</span>
<span class="cm">     * reading a static &quot;gfc&quot; model, so the &quot;epoch&quot; parameter is set to &quot;NULL&quot;.</span>
<span class="cm">     * */</span>
<span class="w">    </span><span class="n">charm_shc_read_gfc</span><span class="p">(</span><span class="n">shcs_in_file</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* At this point, &quot;shcs&quot; should store the loaded spherical harmonic</span>
<span class="cm">     * coefficients.  However, before we continue in our program, we should</span>
<span class="cm">     * check whether the previous function call was successful or not.  To this</span>
<span class="cm">     * end, we shall look into the &quot;err&quot; structure by calling an error handler.</span>
<span class="cm">     * The first parameter of the error handler is the error structure itself,</span>
<span class="cm">     * &quot;err&quot;.  The other parameter says that if there is indeed an error</span>
<span class="cm">     * message in &quot;err&quot;, the program prints details on the error and</span>
<span class="cm">     * subsequently terminates.  If you want to print the error but do not want</span>
<span class="cm">     * to terminate your program, replace &quot;1&quot; by &quot;0&quot; (further details in the</span>
<span class="cm">     * &quot;charm_err&quot; module).  After you call the error handler, you can reuse</span>
<span class="cm">     * the same &quot;err&quot; structure in your program, since the function resets the</span>
<span class="cm">     * error structure to the default empty values.</span>
<span class="cm">     *</span>
<span class="cm">     * It is not absolutely necessary to call the error handler, but it is</span>
<span class="cm">     * really really really recommended to always do so. */</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Now print some more or less randomly chosen spherical harmonic</span>
<span class="cm">     * coefficients */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Let&#39;s start with zonal coefficients */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Harmonic degree */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Harmonic order */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;S(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>


<span class="w">    </span><span class="cm">/* Now some tesseral coefficients */</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;S(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>


<span class="w">    </span><span class="cm">/* And finally some sectorial coefficients */</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;S(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Now let&#39;s save the coefficients to a binary file and then read them back</span>
<span class="cm">     * to another structure for spherical harmonic cofficients.  Just for the</span>
<span class="cm">     * fun...  */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Write the coefficients. */</span>
<span class="w">    </span><span class="n">charm_shc_write_bin</span><span class="p">(</span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs_out_file</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Again, we should call the error handler to see whether the previous call</span>
<span class="cm">     * was successful or not. */</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* And now read back the coefficients to a new &quot;charm_shc&quot; structure called</span>
<span class="cm">     * &quot;shcs2&quot; */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">shcs2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_calloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shcs2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_shc</span><span class="se">\&quot;</span><span class="s"> structure.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">charm_shc_read_bin</span><span class="p">(</span><span class="n">shcs_out_file</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Compute degree variances from &quot;shcs&quot; */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Compute degree variances of the input signal */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">dv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">nmax</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dv</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="n">charm_shc_dv</span><span class="p">(</span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">dv</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print some degree variances */</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Degree variance for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">dv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Degree variance for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">dv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Degree variance for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">dv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Now check whether &quot;shcs&quot; and &quot;shcs2&quot; contain the same coefficients by</span>
<span class="cm">     * computing difference degree variances */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">ddv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">nmax</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ddv</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">charm_shc_ddv</span><span class="p">(</span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">ddv</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print some difference degree variances */</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Difference degree variance for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">                                                                       </span><span class="n">ddv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Difference degree variance for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">                                                                       </span><span class="n">ddv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Difference degree variance for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">                                                                       </span><span class="n">ddv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Remember: always free the memory associated with the CHarm structures</span>
<span class="cm">     * via the special CHarm &quot;charm_*_free*&quot; functions.  Calling the usual</span>
<span class="cm">     * &quot;free&quot; function will not deallocate the memory properly and will lead to</span>
<span class="cm">     * memory leaks. */</span>
<span class="w">    </span><span class="n">charm_err_free</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shcs</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shcs2</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">dv</span><span class="p">),</span><span class="w"> </span><span class="n">free</span><span class="p">(</span><span class="n">ddv</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Great, all done!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_SUCCESS</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="spherical-harmonic-synthesis-and-analysis">
<h3>Spherical harmonic synthesis and analysis<a class="headerlink" href="#spherical-harmonic-synthesis-and-analysis" title="Link to this heading">#</a></h3>
<p>This section shows several examples.</p>
<ul class="simple">
<li><p>A closed-loop test of analysis and synthesis with point data values.  First,
spherical harmonic coefficients are loaded from a text file.  Then, they are
used to synthesize a signal, from which a new set of coefficients is finally
computed by surface spherical harmonic analysis.  The two coefficients sets
are then finally compared (should be equal, that is, the difference degree
amplitudes should be negligibly small).</p></li>
<li><p>A solid spherical harmonic synthesis of point values at scattered points.</p></li>
<li><p>A solid spherical harmonic synthesis of point values at a custom grid of
points.</p></li>
<li><p>A solid spherical harmonic synthesis of block-mean values at scattered cells.</p></li>
<li><p>A solid spherical harmonic synthesis of block mean values at a grid of cells.</p></li>
<li><p>Surface spherical harmonic analysis with block-mean values in cells.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;charm/charm.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* INPUTS */</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="cm">/* Define the path to an input text file with spherical harmonic</span>
<span class="cm">     * coefficients.  For details on the structure of the text file, see the</span>
<span class="cm">     * description of the &quot;charm_shc_read_mtx&quot; function in the &quot;charm_shc&quot;</span>
<span class="cm">     * module. */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">shcs_in_file</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../../data/input/EGM96-degree10-mtx.txt&quot;</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Maximum harmonic degree of coefficients to read.  The same degree is</span>
<span class="cm">     * used later in the harmonic synthesis and harmonic analysis. */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Closed-loop experiment -- Spherical harmonic synthesis and &quot;</span>
<span class="w">           </span><span class="s">&quot;analysis</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Initialize a &quot;charm_shc&quot; structure */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">shcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_calloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shcs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_shc</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Initialize a &quot;charm_err&quot; structure */</span>
<span class="w">    </span><span class="n">charm_err</span><span class="w"> </span><span class="o">*</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_err_init</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_err</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Read spherical harmonic coefficients from the input text file. */</span>
<span class="w">    </span><span class="n">charm_shc_read_mtx</span><span class="p">(</span><span class="n">shcs_in_file</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Now let&#39;s say we do not want to use the zero-degree term.  This can be</span>
<span class="cm">     * achieved simply by setting the respective &quot;C00&quot; coefficient to zero. */</span>
<span class="w">    </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Compute the Gauss--Legendre grid for a given &quot;nmax&quot; on a sphere that is</span>
<span class="cm">     * &quot;1000.0&quot; metres above the reference sphere of spherical harmonic</span>
<span class="cm">     * coefficients. */</span>
<span class="w">    </span><span class="n">charm_point</span><span class="w"> </span><span class="o">*</span><span class="n">grd_pnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_crd_point_gl</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grd_pnt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to compute the Gauss--Legendre grid.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Allocate the memory for the synthesized signal */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Perform the synthesis.  Since the Gauss--Legendre grid resides &quot;1000.0&quot;</span>
<span class="cm">     * metres above the reference sphere of the coefficients, performed is</span>
<span class="cm">     * solid spherical harmonic synthesis. */</span>
<span class="w">    </span><span class="n">charm_shs_point</span><span class="p">(</span><span class="n">grd_pnt</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print some synthesized values */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Print some synthesized values of the signal...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f(%zu, %zu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]);</span>


<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlat</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f(%zu, %zu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]);</span>


<span class="w">    </span><span class="cm">/* Initialize a new structure of spherical harmonic coefficients for</span>
<span class="cm">     * coefficients to be computed by the harmonic analysis.  Used are the same</span>
<span class="cm">     * scalling constants as in &quot;shcs&quot;. */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">shcs2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_calloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">mu</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shcs2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_shc</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Now use the synthesized signal and compute back its spherical harmonic</span>
<span class="cm">     * coefficients by harmonic analysis.  The output coefficients in &quot;shcs2&quot;</span>
<span class="cm">     * should be the same as the input ones &quot;shcs&quot;.  Note that the signal &quot;f&quot;</span>
<span class="cm">     * resides on a sphere that is &quot;1000.0&quot; metres above the reference sphere.</span>
<span class="cm">     * Therefore, the coefficients are automatically properly rescaled to the</span>
<span class="cm">     * desired sphere defined by &quot;shcs2-&gt;r&quot;. */</span>
<span class="w">    </span><span class="n">charm_sha_point</span><span class="p">(</span><span class="n">grd_pnt</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Now check whether &quot;shcs&quot; and &quot;shcs2&quot; are the same by computing their</span>
<span class="cm">     * difference degree amplitudes */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">dda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">nmax</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dda</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">charm_shc_dda</span><span class="p">(</span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">dda</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print some difference degree amplitudes */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Now print the difference degree amplitudes. &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;These should be very small, say, at the order of 1e-18 &quot;</span>
<span class="w">           </span><span class="s">&quot;or less...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Difference degree amplitude for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">dda</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Difference degree amplitude for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">dda</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Difference degree amplitude for harmonic degree %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">dda</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>


<span class="w">    </span><span class="cm">/* We will not need some of the structures and arrays anymore, so let&#39;s</span>
<span class="cm">     * free them. */</span>
<span class="w">    </span><span class="n">charm_crd_point_free</span><span class="p">(</span><span class="n">grd_pnt</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shcs2</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">dda</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Solid spherical harmonic synthesis at scattered points</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Let&#39;s create a &quot;charm_point&quot; structure to store 3 scattered points. */</span>
<span class="w">    </span><span class="n">charm_point</span><span class="w"> </span><span class="o">*</span><span class="n">sctr_pnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_crd_point_calloc</span><span class="p">(</span><span class="n">CHARM_CRD_POINT_SCATTERED</span><span class="p">,</span>
<span class="w">                                                   </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sctr_pnt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_point</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Now let&#39;s feed &quot;sctr_pnt&quot; with some computation points (angular values</span>
<span class="cm">     * must be provided in radians). */</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.1</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.436231</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">lat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-0.9651</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">1.53434</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">lon</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">4.2316</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2000.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">3000.0</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Allocate memory to store the synthesized signal */</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Do the synthesis */</span>
<span class="w">    </span><span class="n">charm_shs_point</span><span class="p">(</span><span class="n">sctr_pnt</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* It&#39;s really this easy! */</span>


<span class="w">    </span><span class="cm">/* Print the synthesized values */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sctr_pnt</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>


<span class="w">    </span><span class="n">charm_crd_point_free</span><span class="p">(</span><span class="n">sctr_pnt</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Solid spherical harmonic synthesis at a custom grid of points</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Initialize a charm_point structure to hold a &quot;5 x 10&quot; point grid. */</span>
<span class="w">    </span><span class="n">grd_pnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_crd_point_calloc</span><span class="p">(</span><span class="n">CHARM_CRD_POINT_GRID</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grd_pnt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_point</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Define some grid points */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlat</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M_PI_2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlat</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="p">;</span>
<span class="w">        </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">lon</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">j</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Initialize an array to store the synthesized signal */</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Do the synthesis */</span>
<span class="w">    </span><span class="n">charm_shs_point</span><span class="p">(</span><span class="n">grd_pnt</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print the synthesized values */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlat</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grd_pnt</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]);</span>


<span class="w">    </span><span class="n">charm_crd_point_free</span><span class="p">(</span><span class="n">grd_pnt</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Solid spherical harmonic synthesis at scattered cells</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Initialize a &quot;charm_cell&quot; structure to hold 3 scattered cells. */</span>
<span class="w">    </span><span class="n">charm_cell</span><span class="w"> </span><span class="o">*</span><span class="n">sctr_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_crd_cell_calloc</span><span class="p">(</span><span class="n">CHARM_CRD_CELL_SCATTERED</span><span class="p">,</span>
<span class="w">                                                  </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sctr_cell</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize scattered cells.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Define more or less randomly some scattered cells */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* The maximum latitude of the first cell */</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.323413435</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* The minimum latitude of the first cell */</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.234323</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* The maximum latitude of the second cell */</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-0.90234320952</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* The minimum latitude of the second cell */</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.4456</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* And so on... */</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">latmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">M_PI_2</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* And now the same, but with the longitudes... */</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.123456789</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.3235</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">4.3445234</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.01</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">lonmin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Finally, we define spherical radii of the scattered cells.  Importantly,</span>
<span class="cm">     * the spherical radius is *constants* over the cells (but may vary from</span>
<span class="cm">     * cell to cell). */</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">      </span><span class="o">=</span><span class="w">  </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">      </span><span class="o">=</span><span class="w">  </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">      </span><span class="o">=</span><span class="w">  </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2000.0</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Initialize an array to store the synthesized signal */</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">ncell</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Do the synthesis */</span>
<span class="w">    </span><span class="n">charm_shs_cell</span><span class="p">(</span><span class="n">sctr_cell</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print the synthesized values */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sctr_cell</span><span class="o">-&gt;</span><span class="n">ncell</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>


<span class="w">    </span><span class="n">charm_crd_cell_free</span><span class="p">(</span><span class="n">sctr_cell</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Solid spherical harmonic synthesis at a grid &quot;</span>
<span class="w">           </span><span class="s">&quot;of cells</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Initialize a &quot;charm_cell&quot; structure to hold a grid of cells with &quot;15&quot;</span>
<span class="cm">     * cells in the latitudinal direction and &quot;30&quot; cells in the longitudinal</span>
<span class="cm">     * direction. */</span>
<span class="w">    </span><span class="n">charm_cell</span><span class="w"> </span><span class="o">*</span><span class="n">grd_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_crd_cell_calloc</span><span class="p">(</span><span class="n">CHARM_CRD_CELL_GRID</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Define some grid cells */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">nlat</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The maximum cell latitudes */</span>
<span class="w">        </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">latmax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M_PI_2</span><span class="w"> </span><span class="o">-</span>
<span class="w">                              </span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">nlat</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* The minimum cell latitudes */</span>
<span class="w">        </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">latmin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M_PI_2</span><span class="w"> </span><span class="o">-</span>
<span class="w">                              </span><span class="p">((</span><span class="kt">double</span><span class="p">)(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">nlat</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                              </span><span class="n">M_PI</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* The spherical radii (may vary with the latitude, but we use</span>
<span class="cm">         * a constant value here, because of the example that follows after</span>
<span class="cm">         * this one). */</span>
<span class="w">        </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1000.0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The minimum cell longitudes */</span>
<span class="w">        </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">lonmin</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">j</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                              </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* The maximum cell longitudes */</span>
<span class="w">        </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">lonmax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">double</span><span class="p">)(</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                              </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Initialize an array to store the synthesized signal */</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">ncell</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Do the synthesis */</span>
<span class="w">    </span><span class="n">charm_shs_cell</span><span class="p">(</span><span class="n">grd_cell</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print some of the synthesized values */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f(%zu, %zu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]);</span>


<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;f(%zu, %zu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grd_cell</span><span class="o">-&gt;</span><span class="n">nlon</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Spherical harmonic analysis of block-mean values in cells</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* In this example, we use the &quot;grd_cell&quot; structure and the signal &quot;f&quot; from</span>
<span class="cm">     * the previous example. */</span>


<span class="w">    </span><span class="cm">/* Initialize a new structure of spherical harmonic coefficients for</span>
<span class="cm">     * coefficients to be recovered from the harmonic analysis.  Used are the</span>
<span class="cm">     * same scalling constants as in &quot;shcs&quot;. */</span>
<span class="w">    </span><span class="n">shcs2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_calloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">mu</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shcs2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_shc</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Do the analysis using the method of the approximate quadrature */</span>
<span class="w">    </span><span class="n">charm_sha_cell</span><span class="p">(</span><span class="n">grd_cell</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">CHARM_SHA_CELL_AQ</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print some of the computed coefficients.  Note that the harmonic</span>
<span class="cm">     * analysis with block-mean values in cells in *not* exact, hence the</span>
<span class="cm">     * coefficients will not be equal to the input ones. */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;S(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>


<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;S(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>


<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;S(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>


<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;S(%3lu,%3lu) = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs2</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="n">charm_crd_cell_free</span><span class="p">(</span><span class="n">grd_cell</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shcs2</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;===========================</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* Free the heap memory */</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="n">charm_err_free</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shcs</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Great, all done!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_SUCCESS</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="first-and-second-order-gradients-gravitational-vector-and-tensor">
<h3>First- and second-order gradients (gravitational vector and tensor)<a class="headerlink" href="#first-and-second-order-gradients-gravitational-vector-and-tensor" title="Link to this heading">#</a></h3>
<p>This example shows how to compute the full gravitational vector and the full
gravitational tensor in the <a class="reference internal" href="definitions.html#lnof"><span class="std std-ref">Local north-oriented reference frame</span></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;charm/charm.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* INPUTS */</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="cm">/* Path to the input file with spherical harmonic coefficients in the &quot;gfc&quot;</span>
<span class="cm">     * format. */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">shcs_file</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../../data/input/EGM96-degree10.gfc&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>


<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="cm">/* Initialize a &quot;charm_err&quot; structure */</span>
<span class="w">    </span><span class="n">charm_err</span><span class="w"> </span><span class="o">*</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_err_init</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_err</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* First, let&#39;s get the maximum harmonic degree stored in &quot;shcs_file&quot;.</span>
<span class="cm">     * This is especially useful to read all coefficients in &quot;shcs_file&quot;</span>
<span class="cm">     * without knowing its maximum harmonic degree a priori. */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_read_gfc</span><span class="p">(</span><span class="n">shcs_file</span><span class="p">,</span><span class="w"> </span><span class="n">CHARM_SHC_NMAX_MODEL</span><span class="p">,</span>
<span class="w">                                            </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Allocate memory for the spherical harmonic coefficients up to degree</span>
<span class="cm">     * &quot;nmax&quot; */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">shcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_malloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shcs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_shc</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Now read all coefficients in &quot;shcs_file&quot; */</span>
<span class="w">    </span><span class="n">charm_shc_read_gfc</span><span class="p">(</span><span class="n">shcs_file</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Compute the Gauss--Legendre point grid for an &quot;nmax&quot; given by the</span>
<span class="cm">     * maximum degree stored in &quot;shcs&quot; and for a radius equal to the reference</span>
<span class="cm">     * sphere, to which the spherical harmonic coefficients are scaled to.  We</span>
<span class="cm">     * intentionally use here the Gauss--Legendre grid instead of the</span>
<span class="cm">     * Driscoll--Healy grids in order to avoid the inaccuracies due to the</span>
<span class="cm">     * singularities at the poles (see the documentation). */</span>
<span class="w">    </span><span class="n">charm_point</span><span class="w"> </span><span class="o">*</span><span class="n">grd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_crd_point_gl</span><span class="p">(</span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to compute the Gauss--Legendre grid.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Total number of gravitational vector elements */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Allocate memory for the gravitational vector elements */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">**</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">np</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">grd</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Compute the full first-order gradient (vector) */</span>
<span class="w">    </span><span class="n">charm_shs_point_grad1</span><span class="p">(</span><span class="n">grd</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Allocate memory for the magnitude of the gravitational vector */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">grd</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Compute the magnitude of the gravitational acceleration (no contribution</span>
<span class="cm">     * due to the centrifugal force is considered here) */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grd</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>


<span class="w">    </span><span class="cm">/* Free the memory associated with the gravitational vector */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Allocate memory for the gravitational tensor elements */</span>
<span class="w">    </span><span class="n">np</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w">  </span><span class="cm">/* There are six tensor elements */</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">np</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">grd</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Now compute the full second-order gradient (tensor) */</span>
<span class="w">    </span><span class="n">charm_shs_point_grad2</span><span class="p">(</span><span class="n">grd</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Check whether &quot;fxx + fyy + fzz&quot; is zero within numerical errors */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">trace_error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span><span class="w">  </span><span class="cm">/* Trace at the</span>
<span class="cm">                                                              * first grid</span>
<span class="cm">                                                              * point of &quot;grd&quot;</span>
<span class="cm">                                                              * */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grd</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">trace_error</span><span class="p">)</span>
<span class="w">            </span><span class="n">trace_error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;The largest error of the gravitational tensor trace is &quot;</span>
<span class="w">           </span><span class="s">&quot;%0.16e s^-2.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">trace_error</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Free the heap memory */</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shcs</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_crd_point_free</span><span class="p">(</span><span class="n">grd</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_free</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Great, all done!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>


<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="gravity-forward-modelling">
<h3>Gravity forward modelling<a class="headerlink" href="#gravity-forward-modelling" title="Link to this heading">#</a></h3>
<p>Given spherical harmonic coefficients of the Moons topography and of its
density (constant, lateral and 3D density), this example computes the
gravitational field implied by the lunar topographic masses.</p>
<p>The lunar shape is here defined by the <code class="docutils literal notranslate"><span class="pre">MoonTopo2600p.shape</span></code> model due to</p>
<blockquote>
<div><ul class="simple">
<li><p>Wieczorek, M. A., Gravity and topography of the terrestrial planets,
Treatise on Geophysics, 10, 153-193, doi:10.1016/B978-0-444-53802-4.00169-X,
2015.</p></li>
</ul>
</div></blockquote>
<p>The density model is due to</p>
<blockquote>
<div><ul class="simple">
<li><p>Goossens, S., Sabaka, T.J., Wieczorek, M.A., Neumann, G.A., Mazarico, E.,
Lemoine, F., Nicholas, J.B., Smith, D.E., Zuber,
M.T. (2020). High-resolution gravity field models from GRAIL data and
implications for models of the density structure of the Moons crust,
Journal of Geophysical Research: Planets, 125, e2019JE006086,
doi:10.1029/2019JE006086.</p></li>
</ul>
</div></blockquote>
<p>The density model of Goossens et al. (2020) was transformed into the form
required by our forward modelling method.  While the transformed models that we
use in this example are realistic, it is not recommended to use them in any
real task.  They were create for learning purposes only.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* IMPORTANT: To compile this code, CHarm must be compiled with the MPFR</span>
<span class="cm"> * support, that is, the &quot;--enable-mpfr&quot; installation flag must be used during</span>
<span class="cm"> * the installation.  If you didn&#39;t enable MPFR, manually delete (or comment</span>
<span class="cm"> * out) all lines between the following marks:</span>
<span class="cm"> *</span>
<span class="cm"> * @@@</span>
<span class="cm"> *</span>
<span class="cm"> * lines to be deleted or commented out</span>
<span class="cm"> *</span>
<span class="cm"> * !!!</span>
<span class="cm"> *</span>
<span class="cm"> * */</span>


<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cm">/* @@@ */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mpfr.h&gt;</span>
<span class="cm">/* !!! */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;charm/charm.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* INPUTS */</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="cm">/* Shape of the gravitating body */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Upper integration limit in spherical radius (topography) */</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="cm">/* Path to spherical harmonic coefficients defining the shape of the Moon</span>
<span class="cm">     * */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">path_shcs_shape</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../../data/input/MoonTopo2600p_to10-tbl.txt&quot;</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Maximum harmonic degree of the lunar topography defined by coefficients</span>
<span class="cm">     * in &quot;path_shcs_shape&quot; */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">shape_nmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>


<span class="w">    </span><span class="cm">/* Lower integration limit in spherical radius (sphere) */</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="cm">/* Radius of the reference sphere */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">rref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1728000.0</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Density of the gravitating body */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Path to spherical harmonic coefficients defining the zero- and</span>
<span class="cm">     * first-order polynomial density coefficients */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">path_shcs_density0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../../data/input/moon-rho0_to10.tbl&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">path_shcs_density1</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../../data/input/moon-rho1_to10.tbl&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path_shcs_density</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">path_shcs_density</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_shcs_density0</span><span class="p">;</span>
<span class="w">    </span><span class="n">path_shcs_density</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_shcs_density1</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Maximum harmonic degrees of the polynomial density coefficients in</span>
<span class="cm">     * &quot;path_shcs_density&quot;. */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">density_nmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span>


<span class="w">    </span><span class="cm">/* Order of the density polynomial */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">density_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Other inputs */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Newton&#39;s gravitational constant (&quot;kg^-1 * m^3 * s^-2&quot;) */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">6.67430e-11</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Mass of the Moon (&quot;kg&quot;) */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">mass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">7.346e22</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Minimum and maximum topography powers.  In theory, &quot;pmax&quot; should be</span>
<span class="cm">     * infinitely large, so higher &quot;pmax&quot; means more complete forward modelling</span>
<span class="cm">     * (but also longer computation times). */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">pmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">pmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Maximum harmonic degree of the output gravitational potential.  Due to</span>
<span class="cm">     * the non-linear relation between topography and its implied gravitational</span>
<span class="cm">     * field, the potential series is spectrally unlimited even if &quot;shape_nmax&quot;</span>
<span class="cm">     * is finite (the only exception is &quot;shape_nmax = 0&quot;).  Therefore, this</span>
<span class="cm">     * value should be as high as reasonably possible in order to mitigate</span>
<span class="cm">     * forward modelling errors. */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nmax_potential</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>






<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Create CHarm&#39;s error structure */</span>
<span class="w">    </span><span class="n">charm_err</span><span class="w"> </span><span class="o">*</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_err_init</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize </span><span class="se">\&quot;</span><span class="s">err</span><span class="se">\&quot;</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Allocate memory for spherical harmonic coefficients that will hold the</span>
<span class="cm">     * shape coefficients */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">shape_shcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_malloc</span><span class="p">(</span><span class="n">shape_nmax</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shape_shcs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize </span><span class="se">\&quot;</span><span class="s">shape_shcs</span><span class="se">\&quot;</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Read the shape coefficients */</span>
<span class="w">    </span><span class="n">charm_shc_read_tbl</span><span class="p">(</span><span class="n">path_shcs_shape</span><span class="p">,</span><span class="w"> </span><span class="n">shape_nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shape_shcs</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Allocate memory for spherical harmonic coefficients that will hold the</span>
<span class="cm">     * polynomial density coefficients and read the coefficients from input</span>
<span class="cm">     * files */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">density_shcs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">density_order</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">density_shcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_malloc</span><span class="p">(</span><span class="n">density_nmax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">density_shcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize </span><span class="se">\&quot;</span><span class="s">density_shcs[i]</span><span class="se">\&quot;</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>


<span class="w">        </span><span class="n">charm_shc_read_tbl</span><span class="p">(</span><span class="n">path_shcs_density</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">density_nmax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
<span class="w">                           </span><span class="n">density_shcs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">        </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Allocate coefficients for the output gravitational potential */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">potential_global_shcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_malloc</span><span class="p">(</span><span class="n">nmax_potential</span><span class="p">,</span>
<span class="w">                                                        </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">potential_global_shcs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize </span><span class="se">\&quot;</span><span class="s">potential_global_shcs</span><span class="se">\&quot;</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Global gravity forward modelling using 3D density */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">charm_gfm_global_density_3d</span><span class="p">(</span><span class="n">shape_shcs</span><span class="p">,</span><span class="w"> </span><span class="n">shape_nmax</span><span class="p">,</span><span class="w"> </span><span class="n">rref</span><span class="p">,</span>
<span class="w">                                </span><span class="n">density_shcs</span><span class="p">,</span><span class="w"> </span><span class="n">density_nmax</span><span class="p">,</span><span class="w"> </span><span class="n">density_order</span><span class="p">,</span>
<span class="w">                                </span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">mass</span><span class="p">,</span>
<span class="w">                                </span><span class="n">pmin</span><span class="p">,</span><span class="w"> </span><span class="n">pmax</span><span class="p">,</span>
<span class="w">                                </span><span class="n">nmax_potential</span><span class="p">,</span>
<span class="w">                                </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                                </span><span class="n">potential_global_shcs</span><span class="p">,</span>
<span class="w">                                </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Now we can compute, say, the gravitational potential using</span>
<span class="cm">     * &quot;potential_global_shcs&quot;.  Let&#39;s do this in the Gauss--Legendre grid that</span>
<span class="cm">     * passes above all lunar masses. */</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="cm">/* Create the Gauss--Legendre grid */</span>
<span class="w">    </span><span class="n">charm_point</span><span class="w"> </span><span class="o">*</span><span class="n">grd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_crd_point_gl</span><span class="p">(</span><span class="n">potential_global_shcs</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">potential_global_shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">25000.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to compute the Gauss--Legendre grid &quot;</span>
<span class="w">                        </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">grd</span><span class="se">\&quot;</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Allocate memory for the gravitational potential to be synthesized */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">vgfm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">grd</span><span class="o">-&gt;</span><span class="n">npoint</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vgfm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to allocate memory for the gravitational &quot;</span>
<span class="w">                        </span><span class="s">&quot;potential </span><span class="se">\&quot;</span><span class="s">vgfm</span><span class="se">\&quot;</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Do the synthesis of the gravitational potential */</span>
<span class="w">    </span><span class="n">charm_shs_point</span><span class="p">(</span><span class="n">grd</span><span class="p">,</span><span class="w"> </span><span class="n">potential_global_shcs</span><span class="p">,</span><span class="w"> </span><span class="n">potential_global_shcs</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">,</span>
<span class="w">                    </span><span class="n">vgfm</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* In CHarm, gravity forward modelling using lateral density is fairly</span>
<span class="cm">     * similar to using 3D density, so we skip it. */</span>


<span class="w">    </span><span class="cm">/* Global gravity forward modelling using constant density */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Constant density of the lunar crust */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">density_const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2550.0</span><span class="p">;</span>


<span class="w">    </span><span class="n">charm_gfm_global_density_const</span><span class="p">(</span><span class="n">shape_shcs</span><span class="p">,</span><span class="w"> </span><span class="n">shape_nmax</span><span class="p">,</span><span class="w"> </span><span class="n">rref</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">density_const</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">mass</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">pmin</span><span class="p">,</span><span class="w"> </span><span class="n">pmax</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">nmax_potential</span><span class="p">,</span>
<span class="w">                                   </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">potential_global_shcs</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* You could now similarly synthesize the gravitational potential, this</span>
<span class="cm">     * time being implied by the constant density model. */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* @@@ */</span>
<span class="w">    </span><span class="cm">/* Spatially restricted gravity forward modelling of near-zone masses using</span>
<span class="cm">     * 3D density */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Minimum and maximum order of the radial derivatives of the output</span>
<span class="cm">     * quantity */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">kmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">kmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Radius of the sphere, on which evaluation points reside */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rref</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">25000.0</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Integration radius in radians */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">psi0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Order of the potential derivative (&quot;0&quot; for potential, &quot;1&quot; for quantities</span>
<span class="cm">     * related to gravitational vector elements, and &quot;2&quot; for quantities related</span>
<span class="cm">     * to gravitational tensor elements) */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Order of the potential derivative with respect to the spherical distance</span>
<span class="cm">     * */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* We want to integrate all masses up to distance &quot;psi0&quot; from evalution</span>
<span class="cm">     * points.  To integrate masses beyond &quot;psi0&quot;, set &quot;zone&quot; to</span>
<span class="cm">     * &quot;CHARM_GFM_FAR_ZONE&quot;. */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">zone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CHARM_GFM_NEAR_ZONE</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Number of bits to represent significands of floating points numbers used</span>
<span class="cm">     * to evaluate truncation coefficients */</span>
<span class="w">    </span><span class="n">mpfr_prec_t</span><span class="w"> </span><span class="n">nbits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span>


<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">**</span><span class="n">potential_cap_shcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">((</span><span class="n">kmax</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kmin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                                            </span><span class="k">sizeof</span><span class="p">(</span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">potential_cap_shcs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize </span><span class="se">\&quot;</span><span class="s">potential_cap_shcs</span><span class="se">\&quot;</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmin</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">kmax</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">potential_cap_shcs</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kmin</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_shc_malloc</span><span class="p">(</span><span class="n">nmax_potential</span><span class="p">,</span>
<span class="w">                                                        </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">potential_cap_shcs</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kmin</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize &quot;</span>
<span class="w">                            </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">potential_cap_shcs[k - kmin]</span><span class="se">\&quot;</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="n">charm_gfm_cap_density_3d</span><span class="p">(</span><span class="n">shape_shcs</span><span class="p">,</span><span class="w"> </span><span class="n">shape_nmax</span><span class="p">,</span><span class="w"> </span><span class="n">rref</span><span class="p">,</span>
<span class="w">                             </span><span class="n">density_shcs</span><span class="p">,</span><span class="w"> </span><span class="n">density_nmax</span><span class="p">,</span><span class="w"> </span><span class="n">density_order</span><span class="p">,</span>
<span class="w">                             </span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">mass</span><span class="p">,</span>
<span class="w">                             </span><span class="n">pmin</span><span class="p">,</span><span class="w"> </span><span class="n">pmax</span><span class="p">,</span>
<span class="w">                             </span><span class="n">kmin</span><span class="p">,</span><span class="w"> </span><span class="n">kmax</span><span class="p">,</span>
<span class="w">                             </span><span class="n">r</span><span class="p">,</span>
<span class="w">                             </span><span class="n">psi0</span><span class="p">,</span>
<span class="w">                             </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span>
<span class="w">                             </span><span class="n">zone</span><span class="p">,</span>
<span class="w">                             </span><span class="n">nbits</span><span class="p">,</span>
<span class="w">                             </span><span class="n">nmax_potential</span><span class="p">,</span>
<span class="w">                             </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                             </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                             </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                             </span><span class="n">potential_cap_shcs</span><span class="p">,</span>
<span class="w">                             </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Spatially restricted gravity forward modelling of near-zone masses using</span>
<span class="cm">     * constant density */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">charm_gfm_cap_density_const</span><span class="p">(</span><span class="n">shape_shcs</span><span class="p">,</span><span class="w"> </span><span class="n">shape_nmax</span><span class="p">,</span><span class="w"> </span><span class="n">rref</span><span class="p">,</span>
<span class="w">                                </span><span class="n">density_const</span><span class="p">,</span>
<span class="w">                                </span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">mass</span><span class="p">,</span>
<span class="w">                                </span><span class="n">pmin</span><span class="p">,</span><span class="w"> </span><span class="n">pmax</span><span class="p">,</span>
<span class="w">                                </span><span class="n">kmin</span><span class="p">,</span><span class="w"> </span><span class="n">kmax</span><span class="p">,</span>
<span class="w">                                </span><span class="n">r</span><span class="p">,</span>
<span class="w">                                </span><span class="n">psi0</span><span class="p">,</span>
<span class="w">                                </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span>
<span class="w">                                </span><span class="n">zone</span><span class="p">,</span>
<span class="w">                                </span><span class="n">nbits</span><span class="p">,</span>
<span class="w">                                </span><span class="n">nmax_potential</span><span class="p">,</span>
<span class="w">                                </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                                </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                                </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">                                </span><span class="n">potential_cap_shcs</span><span class="p">,</span>
<span class="w">                                </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Let&#39;s compute some Molodensky&#39;s truncation coefficients, which are used</span>
<span class="cm">     * internally whenever calling the &quot;charm_gfm_cap_density_*&quot; routines. */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Allocate memory for trunction coefficients */</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="cm">/* Get the number of trunction coefficients */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">q_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_gfm_cap_nq</span><span class="p">(</span><span class="n">nmax_potential</span><span class="p">,</span><span class="w"> </span><span class="n">pmax</span><span class="p">,</span><span class="w"> </span><span class="n">kmin</span><span class="p">,</span><span class="w"> </span><span class="n">kmax</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">density_order</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="n">mpfr_t</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mpfr_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">q_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">mpfr_t</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="n">CHARM_ERR_MALLOC_FAILURE</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">q_size</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">mpfr_init2</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">nbits</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>


<span class="w">    </span><span class="cm">/* To compute the truncation coefficients, CHarm requires some floating</span>
<span class="cm">     * point numbers to be provided as the &quot;mpfr_t&quot; data type, so let&#39;s do the</span>
<span class="cm">     * conversion.  We chose &quot;rref&quot;, &quot;r&quot; and &quot;psi0&quot; such that they can be</span>
<span class="cm">     * represented as &quot;double&quot;s exactly, so using &quot;mpfr_set_d&quot; should be safe.</span>
<span class="cm">     * Otherwise, say, if &quot;psi0 = 0.1234567&quot;, use &quot;mpfr_set_str&quot; instead. */</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="n">mpfr_t</span><span class="w"> </span><span class="n">mpfr_rref</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_r</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_psi0</span><span class="p">;</span>
<span class="w">    </span><span class="n">mpfr_inits2</span><span class="p">(</span><span class="n">nbits</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_rref</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_r</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_psi0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">mpfr_ptr</span><span class="p">)</span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">mpfr_set_d</span><span class="p">(</span><span class="n">mpfr_rref</span><span class="p">,</span><span class="w"> </span><span class="n">rref</span><span class="p">,</span><span class="w"> </span><span class="n">MPFR_RNDN</span><span class="p">);</span>
<span class="w">    </span><span class="n">mpfr_set_d</span><span class="p">(</span><span class="n">mpfr_r</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">MPFR_RNDN</span><span class="p">);</span>
<span class="w">    </span><span class="n">mpfr_set_d</span><span class="p">(</span><span class="n">mpfr_psi0</span><span class="p">,</span><span class="w"> </span><span class="n">psi0</span><span class="p">,</span><span class="w"> </span><span class="n">MPFR_RNDN</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>


<span class="w">    </span><span class="cm">/* Compute the trucation coefficients */</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="n">charm_gfm_cap_q</span><span class="p">(</span><span class="n">mpfr_rref</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_r</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_psi0</span><span class="p">,</span>
<span class="w">                    </span><span class="n">nmax_potential</span><span class="p">,</span><span class="w"> </span><span class="n">pmax</span><span class="p">,</span><span class="w"> </span><span class="n">kmin</span><span class="p">,</span><span class="w"> </span><span class="n">kmax</span><span class="p">,</span><span class="w"> </span><span class="n">density_order</span><span class="p">,</span>
<span class="w">                    </span><span class="n">CHARM_GFM_NEAR_ZONE</span><span class="p">,</span><span class="w"> </span><span class="n">CHARM_GFM_Q00</span><span class="p">,</span><span class="w"> </span><span class="n">nbits</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>


<span class="w">    </span><span class="cm">/* Free the memory associated with the trunction coefficients */</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="n">mpfr_clears</span><span class="p">(</span><span class="n">mpfr_rref</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_r</span><span class="p">,</span><span class="w"> </span><span class="n">mpfr_psi0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">mpfr_ptr</span><span class="p">)</span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">q_size</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">mpfr_clear</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* NOTE: At this point, the memory associated with &quot;q&quot; should be released.</span>
<span class="cm">     * If you are linking against &quot;glibc&quot; (which is the case on most Linux</span>
<span class="cm">     * distributions), the memory may not, however, be released completely.</span>
<span class="cm">     * This is not because of some bug in MPFR or CHarm, but instead it seems</span>
<span class="cm">     * to be the default behaviour of the GNU&#39;s &quot;glibc&quot; library.  It seems that</span>
<span class="cm">     * if you allocate a large amount of small memory chunks using malloc, as</span>
<span class="cm">     * it happens in our code with</span>
<span class="cm">     *</span>
<span class="cm">     *      for (size_t j = 0; j &lt; q_size; j++)</span>
<span class="cm">     *          mpfr_init2(q[j], nbits);</span>
<span class="cm">     *</span>
<span class="cm">     * then &quot;glibc&quot; may not release the memory completely when we called</span>
<span class="cm">     *</span>
<span class="cm">     *      for (size_t j = 0; j &lt; q_size; j++)</span>
<span class="cm">     *          mpfr_clear(q[j]);</span>
<span class="cm">     *</span>
<span class="cm">     * In our example, &quot;q_size&quot; is fairly low though, so this should now be</span>
<span class="cm">     * a problem in this case.</span>
<span class="cm">     *</span>
<span class="cm">     * If you are linking against &quot;glibc&quot;, your &quot;q_size&quot; is large and you want</span>
<span class="cm">     * to release all the memory, call now</span>
<span class="cm">     *</span>
<span class="cm">     *      malloc_trim(0);</span>
<span class="cm">     *</span>
<span class="cm">     * Importantly, &quot;malloc_trim&quot; is a GNU extension, so you can call it only</span>
<span class="cm">     * if you are linking agains &quot;glibc&quot;.  If you are using, say, &quot;musl&quot;, you</span>
<span class="cm">     * must not call &quot;malloc_trim&quot;.</span>
<span class="cm">     *</span>
<span class="cm">     * Luckily, CHarm detects on compilation whether we are linking against</span>
<span class="cm">     * &quot;glibc&quot;.  If so, &quot;malloc_trim&quot; is called before returning from functions</span>
<span class="cm">     * dealing internally with truncation coefficients.  Therefore, you do not</span>
<span class="cm">     * have to worry that CHarm will leave some unreleased memory.  But if you</span>
<span class="cm">     * allocate memory for truncation coefficients outside CHarm, as we did in</span>
<span class="cm">     * this example, it is your own responsibility to release or to not release</span>
<span class="cm">     * the memory you allocated.</span>
<span class="cm">     *</span>
<span class="cm">     * For more details, look inside &quot;src/mpfr/mpfr_flush_unreleased_memory.h&quot;.</span>
<span class="cm">     *</span>
<span class="cm">     * */</span>
<span class="w">    </span><span class="cm">/* ..................................................................... */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* !!! */</span>


<span class="w">    </span><span class="cm">/* Free the heap memory */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">charm_err_free</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shape_shcs</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">density_order</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">density_shcs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">potential_global_shcs</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmin</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">kmax</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">potential_cap_shcs</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kmin</span><span class="p">]);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">potential_cap_shcs</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_crd_point_free</span><span class="p">(</span><span class="n">grd</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">vgfm</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Great, all done!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_SUCCESS</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fourier-coefficients-of-legendre-functions">
<h3>Fourier coefficients of Legendre functions<a class="headerlink" href="#fourier-coefficients-of-legendre-functions" title="Link to this heading">#</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;charm/charm.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Maximum harmonic degree to compute the Fourier coefficients of Legendre</span>
<span class="cm">     * functions */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Initialize a structure to store the Fourier coefficients of Legendre</span>
<span class="cm">     * functions */</span>
<span class="w">    </span><span class="n">charm_pnmj</span><span class="w"> </span><span class="o">*</span><span class="n">pnmj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_leg_pnmj_calloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">CHARM_LEG_PMNJ</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pnmj</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_pnmj</span><span class="se">\&quot;</span><span class="s"> &quot;</span>
<span class="w">                        </span><span class="s">&quot;structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Initialize an &quot;charm_err&quot; structure */</span>
<span class="w">    </span><span class="n">charm_err</span><span class="w"> </span><span class="o">*</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_err_init</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_err</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Compute the Fourier coefficients */</span>
<span class="w">    </span><span class="n">charm_leg_pnmj_coeffs</span><span class="p">(</span><span class="n">pnmj</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print some Fourier coefficients */</span>
<span class="w">    </span><span class="cm">/* Harmonic degree */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">123</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Harmonic order */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Wave-number-related variable */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Wave-number (computed from &quot;j&quot;; for details, see the &quot;charm_leg&quot;</span>
<span class="cm">     * module)*/</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_leg_pnmj_j2k</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Fourier coefficient for degree %lu, order %lu and &quot;</span>
<span class="w">           </span><span class="s">&quot;wave-number %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">pnmj</span><span class="o">-&gt;</span><span class="n">pnmj</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>


<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">360</span><span class="p">;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">358</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">101</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_leg_pnmj_j2k</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Fourier coefficient for degree %lu, order %lu and &quot;</span>
<span class="w">           </span><span class="s">&quot;wave-number %lu = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">pnmj</span><span class="o">-&gt;</span><span class="n">pnmj</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>


<span class="w">    </span><span class="cm">/* Free the heap memory */</span>
<span class="w">    </span><span class="n">charm_leg_pnmj_free</span><span class="p">(</span><span class="n">pnmj</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_free</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Great, all done!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="integrals">
<h3>Integrals<a class="headerlink" href="#integrals" title="Link to this heading">#</a></h3>
<p>Lets compute an integral of a product of two spherical harmonics over
a restricted domain on the unit sphere.  Then, we do the same, but with the
product of Legendre functions only.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;charm/charm.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Type of the first spherical harmonic function, its harmonic degree and</span>
<span class="cm">     * order, respectively */</span>
<span class="w">    </span><span class="kt">_Bool</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="cm">/* The &quot;cos&quot; spherical harmonic function */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">287</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">122</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Type of the second spherical harmonic function, its harmonic degree and</span>
<span class="cm">     * order, respectively */</span>
<span class="w">    </span><span class="kt">_Bool</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="cm">/* The &quot;sin&quot; spherical harmonic function */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">34</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Minimum and maximum co-latitudes of the integration domain */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">cltmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">cltmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.9</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Minimum and maximum longitudes of the integration domain */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">lonmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">lonmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.6</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Initialize the Fourier coefficients of Legendre functions */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CHARM_MAX</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_pnmj</span><span class="w"> </span><span class="o">*</span><span class="n">pnmj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_leg_pnmj_calloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">CHARM_LEG_PMNJ</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pnmj</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_pnmj</span><span class="se">\&quot;</span><span class="s"> &quot;</span>
<span class="w">                        </span><span class="s">&quot;structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Initialize an &quot;charm_err&quot; structure */</span>
<span class="w">    </span><span class="n">charm_err</span><span class="w"> </span><span class="o">*</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_err_init</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to initialize the </span><span class="se">\&quot;</span><span class="s">charm_err</span><span class="se">\&quot;</span><span class="s"> structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Compute the Fourier coefficients */</span>
<span class="w">    </span><span class="n">charm_leg_pnmj_coeffs</span><span class="p">(</span><span class="n">pnmj</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Compute the integral of a product of two spherical harmonics */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">iy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_integ_yi1n1m1yi2n2m2</span><span class="p">(</span><span class="n">cltmin</span><span class="p">,</span><span class="w"> </span><span class="n">cltmax</span><span class="p">,</span><span class="w"> </span><span class="n">lonmin</span><span class="p">,</span><span class="w"> </span><span class="n">lonmax</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">i1</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">i2</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">,</span><span class="w"> </span><span class="n">pnmj</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Print the value of the integral */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;The integral of the product of two spherical harmonics &quot;</span>
<span class="w">           </span><span class="s">&quot;i1 = %d, n1 = %lu, m1 = %lu, i2 = %d, n2 = %lu, m2 = %lu &quot;</span>
<span class="w">           </span><span class="s">&quot;is %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i1</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">,</span><span class="w"> </span><span class="n">iy</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Now compute the integral of a product of two Legendre functions over a</span>
<span class="cm">     * restricted domain */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_integ_pn1m1pn2m2</span><span class="p">(</span><span class="n">cltmin</span><span class="p">,</span><span class="w"> </span><span class="n">cltmax</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">,</span><span class="w"> </span><span class="n">pnmj</span><span class="p">,</span>
<span class="w">                                       </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;The integral of the product of two Legendre functions &quot;</span>
<span class="w">           </span><span class="s">&quot;n1 = %lu, m1 = %lu, n2 = %lu, m2 = %lu &quot;</span>
<span class="w">           </span><span class="s">&quot;is %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">,</span><span class="w"> </span><span class="n">ip</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Free the heap memory */</span>
<span class="w">    </span><span class="n">charm_err_free</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_leg_pnmj_free</span><span class="p">(</span><span class="n">pnmj</span><span class="p">);</span>


<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="distributed-computing-with-mpi">
<h3>Distributed computing with MPI<a class="headerlink" href="#distributed-computing-with-mpi" title="Link to this heading">#</a></h3>
<p>This example shows how to use CHarm with distributed-memory systems using MPI.</p>
<p>Compile the source code with <code class="docutils literal notranslate"><span class="pre">mpicc</span></code> or similar, e.g., by:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mpicc<span class="w"> </span>mpi.c<span class="w"> </span>-l:libcharm.a<span class="w"> </span>-lfftw3<span class="w"> </span>-lm
</pre></div>
</div>
<p>Launch the program using three MPI processes (required by the program), e.g.,:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mpiexec<span class="w"> </span>-n<span class="w"> </span><span class="m">3</span><span class="w"> </span>./a.out
</pre></div>
</div>
<p>As a side note, you can run the program using an actual distributed-memory
system but also using an ordinary shared-memory system having at least 3 CPUs.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mpi.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;charm/charm.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Initialize MPI execution environment */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Note that the previous &quot;MPI_Init&quot; call does not allow to combined MPI</span>
<span class="cm">     * and OpenMP parallelization techniques.  For best performance, however,</span>
<span class="cm">     * it is strongly advised to indeed combine MPI and OpenMP.</span>
<span class="cm">     *</span>
<span class="cm">     * Briefly, the recommended strategy is to use one MPI process per</span>
<span class="cm">     * shared-memory system.  This will minimize the data transfer between the</span>
<span class="cm">     * computing nodes, which, in case of high-degree spherical harmonics</span>
<span class="cm">     * transforms, is usually the bottleneck.  Then, within each shared-memory</span>
<span class="cm">     * system, all OpenMP threads can be used.</span>
<span class="cm">     *</span>
<span class="cm">     * For best performance, we recommend to use the MPI&#39;s</span>
<span class="cm">     * &quot;MPI_THREAD_FUNNELED&quot; parallelization mode (only the thread that called</span>
<span class="cm">     * &quot;MPI_Init_thread&quot; will make MPI calls).  Remember that to combine MPI</span>
<span class="cm">     * and OpenMP, the MPI execution environment has to be initialized like</span>
<span class="cm">     * this:</span>
<span class="cm">     *</span>
<span class="cm">     * int provided;</span>
<span class="cm">     * MPI_Init_thread(&amp;argc, &amp;argv, MPI_THREAD_FUNNELED, &amp;provided);</span>
<span class="cm">     * if (provided != MPI_THREAD_FUNNELED)</span>
<span class="cm">     * {</span>
<span class="cm">     *     fprintf(stderr, &quot;MPI didn&#39;t provide MPI_THREAD_FUNNELED\n&quot;);</span>
<span class="cm">     *     exit(CHARM_FAILURE);</span>
<span class="cm">     * }</span>
<span class="cm">     *</span>
<span class="cm">     * */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Identify who I am and the number of MPI processes */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* MPI communicator */</span>
<span class="w">    </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">comm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">;</span>


<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="p">;</span><span class="w">  </span><span class="cm">/* This is who I am */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">  </span><span class="cm">/* This is the total number of MPI processes */</span>
<span class="w">    </span><span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span>
<span class="w">    </span><span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* We assume this code is launched at 3 MPI processes. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;This program must be launched at 3 MPI processes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Initialize an error structure */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Note that we do not call &quot;charm_err_init&quot; with distributed computing */</span>
<span class="w">    </span><span class="n">charm_err</span><span class="w"> </span><span class="o">*</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_mpi_err_init</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* If the previous function call failed at any process, &quot;err&quot; will be</span>
<span class="cm">     * &quot;NULL&quot; at all processes in &quot;comm&quot;. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to create the </span><span class="se">\&quot;</span><span class="s">charm_err</span><span class="se">\&quot;</span><span class="s"> structure&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Make up some fake spherical harmonic coefficients up to degree &quot;10&quot; */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Maximum harmonic degree of spherical harmonic coefficients */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* Each MPI process may hold zero, one or more chunks of spherical harmonic</span>
<span class="cm">     * coefficients.  A chunk of spherical harmonic coefficients denotes all</span>
<span class="cm">     * spherical harmonic coefficients of orders &quot;m1, m1 + 1, ..., m2&quot;.</span>
<span class="cm">     *</span>
<span class="cm">     * In this example, the MPI processes with ranks &quot;0&quot; and &quot;1&quot; will hold two</span>
<span class="cm">     * chunks while only a single chunk will be assigned to rank &quot;2&quot;.  This is</span>
<span class="cm">     * just to demonstrate that the number of chunks may vary across MPI</span>
<span class="cm">     * processes.</span>
<span class="cm">     *</span>
<span class="cm">     * Not shown here, but it is absolutely OK for some processes to store zero</span>
<span class="cm">     * chunks, that is, no spherical harmonic coefficients at all.  For</span>
<span class="cm">     * instance, if you have &quot;100&quot; MPI processes and you want to create the</span>
<span class="cm">     * &quot;charm_shc&quot; structure up to degree &quot;0&quot;, you assign one chunk starting</span>
<span class="cm">     * and ending at order &quot;0&quot; to one process and zero chunks to all the</span>
<span class="cm">     * remaining &quot;99&quot; processes.  */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">local_nchunk</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="n">local_nchunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">local_nchunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>


<span class="w">    </span><span class="cm">/* To split spherical harmonic coefficients among MPI processes (that is,</span>
<span class="cm">     * to define chunks), we need an array of &quot;2 * local_nchunk&quot; elements.  For</span>
<span class="cm">     * ranks &quot;0&quot; and &quot;1&quot;, we thus need four elements but only two elements for</span>
<span class="cm">     * rank &quot;2&quot;.  For simplicity, we allocate here, however, an array of four</span>
<span class="cm">     * elements for all processes which is fine.</span>
<span class="cm">     *</span>
<span class="cm">     * In the example below, we hard-coded the chunks for demonstration</span>
<span class="cm">     * purposes.  However, this is likely not the strategy you will use in</span>
<span class="cm">     * practice, especially if the number of MPI processes is large.  Instead,</span>
<span class="cm">     * you&#39;ll probably fill &quot;local_order&quot; based on the &quot;local_nchunk&quot;, &quot;size&quot;</span>
<span class="cm">     * and &quot;rank&quot; variables or so. */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">local_order</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The first chunk will consist of all spherical harmonic coefficients</span>
<span class="cm">         * of order &quot;0&quot; */</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>


<span class="w">        </span><span class="cm">/* The second chunk will hold all coefficients of orders from &quot;1&quot; to</span>
<span class="cm">         * &quot;2&quot; */</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The first chunk at another MPI process will consist of all</span>
<span class="cm">         * coefficients of orders from &quot;3&quot; to &quot;5&quot; */</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>


<span class="w">        </span><span class="cm">/* The second chunk consists of all coefficients of order &quot;6&quot; */</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* This process has one chunk only, starting at order &quot;7&quot; and ending at</span>
<span class="cm">         * &quot;10&quot; */</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">        </span><span class="n">local_order</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Note that CHarm offers rather flexible distribution of spherical</span>
<span class="cm">     * harmonic coefficients among MPI processes.  This has many benefits.  If</span>
<span class="cm">     * one of your computing nodes has lower/higher RAM capacity than the other</span>
<span class="cm">     * nodes, you can assign lower/higher number of spherical harmonic</span>
<span class="cm">     * coefficients to this process.  Or you can distribute all coefficients</span>
<span class="cm">     * evenly among all processes to ensure the memory consumption on all nodes</span>
<span class="cm">     * will be even and so on and so forth. */</span>


<span class="w">    </span><span class="cm">/* Now allocate the memory for a distributed &quot;charm_shc&quot; structure.  The</span>
<span class="cm">     * structure will be distributed among all MPI processed in &quot;comm&quot; based on</span>
<span class="cm">     * our &quot;local_nchunk&quot; and &quot;local_order&quot;. */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">shcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_mpi_shc_malloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">local_nchunk</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">local_order</span><span class="p">,</span><span class="w"> </span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* At this point, we have to check that the previous function call was</span>
<span class="cm">     * successful.  We can do this either be verifying that &quot;shcs&quot; is not</span>
<span class="cm">     * &quot;NULL&quot; and/or we can use the CHarm&#39;s error handler.</span>
<span class="cm">     *</span>
<span class="cm">     * Many things could go wrong when calling &quot;charm_mpi_shc_malloc&quot; and other</span>
<span class="cm">     * routines from the &quot;mpi&quot; module.  For instance, there might be not enough</span>
<span class="cm">     * memory available at some computing node(s), the partitioning of</span>
<span class="cm">     * spherical harmonic coefficients to chunks might be wrong (e.g., by</span>
<span class="cm">     * leaving some gaps by not specifying some spherical harmonic order(s) in</span>
<span class="cm">     * &quot;local_order&quot;, or by introducing overlaps between some chunks), the MPI</span>
<span class="cm">     * communicator &quot;comm&quot; might be invalid and so on. You should therefore</span>
<span class="cm">     * always call an error handler.  It will try to describe the cause of the</span>
<span class="cm">     * error, hopefully allowing you to easily fix it. */</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Now fill &quot;shcs&quot; with some fake spherical harmonic coefficients.</span>
<span class="cm">     * Usually, you will read these coefficients from files on your hard drive.</span>
<span class="cm">     * But for simplicity, we use some artificial coefficients in this example.</span>
<span class="cm">     * */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">local_nchunk</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">local_order</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">j</span><span class="p">];</span>
<span class="w">             </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">local_order</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">m</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">                </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Important: Never access coefficients that are not owned by the process</span>
<span class="cm">     * that is trying to access the coefficients.</span>
<span class="cm">     *</span>
<span class="cm">     * For instance, all coefficients of order &quot;8&quot; are now owned by (stored at)</span>
<span class="cm">     * MPI process with rank &quot;2&quot;.  This</span>
<span class="cm">     *</span>
<span class="cm">     *      &quot;shcs-&gt;c[8][8 - 8]&quot;</span>
<span class="cm">     *</span>
<span class="cm">     * will thus fail badly at processes with ranks other than &quot;2&quot;. */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Now let&#39;s prepare a Gauss--Legendre grid that will be distributed among</span>
<span class="cm">     * the MPI processes */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Get the number of latitudes and longitudes of the Gauss--Legendre grid</span>
<span class="cm">     * that correspond to maximum harmonic degree &quot;nmax&quot; */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nlat</span><span class="p">,</span><span class="w"> </span><span class="n">nlon</span><span class="p">;</span>
<span class="w">    </span><span class="n">charm_crd_point_gl_shape</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlat</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nlon</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* For our &quot;nmax = 10&quot;, &quot;nlat&quot; will be &quot;11&quot;.  We will thus have the</span>
<span class="cm">     * following latitudes in the Gauss--Legendre grid: &quot;lat0, lat1, lat2, ...,</span>
<span class="cm">     * lat10&quot;. */</span>


<span class="w">    </span><span class="cm">/* Similarly as we specified chunks of spherical harmonic coefficients, now</span>
<span class="cm">     * we have to split the Gauss--Legendre grid into latitudinal chunks.</span>
<span class="cm">     * Naturally, the sum of &quot;local_nlat&quot; across all processes must match</span>
<span class="cm">     * &quot;nlat&quot;.  This is automatically checked when calling</span>
<span class="cm">     * &quot;charm_mpi_crd_point_gl&quot; below.</span>
<span class="cm">     *</span>
<span class="cm">     * Again, assigning no latitudinal chunks to some MPI process is fairly OK.</span>
<span class="cm">     * Below, this would translate into assigning &quot;0&quot; to &quot;local_nlat&quot; at one or</span>
<span class="cm">     * more processes.  This would of course necessitate to increase</span>
<span class="cm">     * &quot;local_nlat&quot; at other processes. */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">local_nlat</span><span class="p">,</span><span class="w"> </span><span class="n">local_0_start</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* This MPI process will hold 2 latitudes, &quot;lat1&quot; and &quot;lat9&quot;. */</span>
<span class="w">        </span><span class="n">local_nlat</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">local_0_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* This process also holds two latitudes, &quot;lat0&quot; and &quot;lat10&quot;.  We</span>
<span class="cm">         * intentionally put &quot;lat0&quot; to the process of rank &quot;1&quot; to demonstrate</span>
<span class="cm">         * that CHarm does not care about which chunk is stored by which MPI</span>
<span class="cm">         * process. */</span>
<span class="w">        </span><span class="n">local_nlat</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">local_0_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* This process holds seven latitudes, &quot;lat2, lat3, ..., lat8&quot; */</span>
<span class="w">        </span><span class="n">local_nlat</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">        </span><span class="n">local_0_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* Note that &quot;lat0 = -lat10&quot;, &quot;lat1 = -lat9&quot;, ..., that is Gauss--Legendre</span>
<span class="cm">     * grids are symmetric with respect to the equator.  In case of symmetric</span>
<span class="cm">     * grids in general, each process must hold the latitudes at both</span>
<span class="cm">     * hemispheres.  The only exception is that MPI process, which holds the</span>
<span class="cm">     * equator (if there is any).  In that case, &quot;local_nlat&quot; must be odd.</span>
<span class="cm">     * This happens with Gauss--Legendre grids and even &quot;nmax&quot;.  See the</span>
<span class="cm">     * documentation to &quot;charm_mpi_crd_point_gl&quot;. */</span>


<span class="w">    </span><span class="n">charm_point</span><span class="w"> </span><span class="o">*</span><span class="n">glg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_mpi_crd_point_gl</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">local_nlat</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">local_0_start</span><span class="p">,</span><span class="w"> </span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Let&#39;s print the latitudes, spherical radii and integration weights in</span>
<span class="cm">     * &quot;glg&quot;.  The longitudes are not printed as they are the same at all</span>
<span class="cm">     * processes.  The data will be printed in the rank order. */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">glg</span><span class="o">-&gt;</span><span class="n">local_nlat</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;rank %d: glg-&gt;lat[%zu] = %23.16e, &quot;</span>
<span class="w">                       </span><span class="s">&quot;glg-&gt;r[%zu] = %23.16e, glg-&gt;w[%zu] = %23.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                       </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">glg</span><span class="o">-&gt;</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">glg</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">glg</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>


<span class="w">        </span><span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* At this point, we have spherical harmonic coefficients in &quot;shcs&quot; as well</span>
<span class="cm">     * as computing points in &quot;glg&quot; distributed across MPI processes, so we can</span>
<span class="cm">     * do some distributed spherical harmonic synthesis and analysis. */</span>


<span class="w">    </span><span class="cm">/* Spherical harmonic synthesis */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* At this point, each process holds &quot;glg-&gt;local_npoint&quot; points.  The sum</span>
<span class="cm">     * of &quot;glg-&gt;local_npoint&quot; across all MPI processes thus yields the total</span>
<span class="cm">     * number of grid points &quot;glg-&gt;npoint&quot;.  Let&#39;s now allocate memory for the</span>
<span class="cm">     * local signal &quot;f&quot; that is to be synthesized by each MPI process */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">glg</span><span class="o">-&gt;</span><span class="n">local_npoint</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;malloc failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* Do the synthesis */</span>
<span class="w">    </span><span class="n">charm_shs_point</span><span class="p">(</span><span class="n">glg</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Note that &quot;f&quot; is now distributed among MPI processes.  The distribution</span>
<span class="cm">     * is given by &quot;glg&quot;. */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Spherical harmonic analysis */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* Now we want to compute by spherical harmonic analysis coefficients from</span>
<span class="cm">     * &quot;f&quot;, which is distributed.  First, we need to allocate a new distributed</span>
<span class="cm">     * &quot;charm_shc&quot; structure.  For simplicity, the distribution will be the</span>
<span class="cm">     * same as with &quot;shcs&quot; but this is not required. */</span>
<span class="w">    </span><span class="n">charm_shc</span><span class="w"> </span><span class="o">*</span><span class="n">shcs_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charm_mpi_shc_malloc</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">local_nchunk</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">local_order</span><span class="p">,</span><span class="w"> </span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Now the analysis.  Note that the number of locally stored points in</span>
<span class="cm">     * &quot;glg&quot; (&quot;glg-&gt;local_npoint&quot;) must match the number of elements in &quot;f&quot; and</span>
<span class="cm">     * that the elements of &quot;f&quot; must be ordered properly. */</span>
<span class="w">    </span><span class="n">charm_sha_point</span><span class="p">(</span><span class="n">glg</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">shcs_out</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs_out</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* &quot;shcs&quot; and &quot;shcs_out&quot; are the same, as can easily be verified.  Their</span>
<span class="cm">     * differences should not exceed the order of, say, &quot;10**-13&quot; or so.  We</span>
<span class="cm">     * print the outputs first in order according to the rank of the process</span>
<span class="cm">     * and then in order given by &quot;local_order&quot;. */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">local_nchunk</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">local_order</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">j</span><span class="p">];</span>
<span class="w">                     </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">local_order</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">m</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;rank %d: Cref_{%2lu, %2lu} = %0.16e, &quot;</span>
<span class="w">                               </span><span class="s">&quot;Cnew_{%2lu, %2lu} = %0.16e, diff = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                               </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span>
<span class="w">                               </span><span class="n">shcs_out</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">],</span>
<span class="w">                               </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">shcs_out</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">                        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;rank %d: Sref_{%2lu, %2lu} = %0.16e, &quot;</span>
<span class="w">                               </span><span class="s">&quot;Snew_{%2lu, %2lu} = %0.16e, diff = %0.16e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                               </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span>
<span class="w">                               </span><span class="n">shcs_out</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">],</span>
<span class="w">                               </span><span class="n">shcs</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">shcs_out</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">]);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>


<span class="w">        </span><span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* IMPORTANT NOTE */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="cm">/* CHarm has some global parameters that should be tuned to get the best</span>
<span class="cm">     * performance with MPI.  For instance, there is the</span>
<span class="cm">     * &quot;charm_glob_sha_block_lat_multiplier&quot; variable, which has enormous</span>
<span class="cm">     * impact on the performance of &quot;charm_sha_point&quot; in real-world high-degree</span>
<span class="cm">     * applications.</span>
<span class="cm">     *</span>
<span class="cm">     * For demonstration purposes, let&#39;s change its value now and repeat the</span>
<span class="cm">     * analysis.  This has no effect on the results of course.</span>
<span class="cm">     *</span>
<span class="cm">     * See the documentation of the &quot;glob&quot; module for this and other associated</span>
<span class="cm">     * variables. */</span>
<span class="w">    </span><span class="n">charm_glob_sha_block_lat_multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">    </span><span class="n">charm_sha_point</span><span class="p">(</span><span class="n">glg</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">shcs_out</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">,</span><span class="w"> </span><span class="n">shcs_out</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_handler</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* Free the memory */</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shcs</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_shc_free</span><span class="p">(</span><span class="n">shcs_out</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_crd_point_free</span><span class="p">(</span><span class="n">glg</span><span class="p">);</span>
<span class="w">    </span><span class="n">charm_err_free</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Great, all done by process %d of %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>


<span class="w">    </span><span class="n">MPI_Finalize</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/* --------------------------------------------------------------------- */</span>


<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">CHARM_SUCCESS</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* ===================================================================== */</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="charm-in-single-and-quadruple-precision">
<span id="charm-in-single-and-quad-precision"></span><h2>CHarm in single and quadruple precision<a class="headerlink" href="#charm-in-single-and-quadruple-precision" title="Link to this heading">#</a></h2>
<p>A few simple rules need to be obeyed in single and quadruple precision.</p>
<ul>
<li><p>Make sure you have compiled CHarm in single or quadruple precision (see
<a class="reference internal" href="install.html#installing"><span class="std std-ref">Installing</span></a>), whichever you need.</p></li>
<li><p>Replace every occurrence of the <code class="docutils literal notranslate"><span class="pre">charm_*</span></code> prefix with <code class="docutils literal notranslate"><span class="pre">charmf_*</span></code> for
single precision and <code class="docutils literal notranslate"><span class="pre">charmq_*</span></code> for quadruple precision.  This applies to
your own code, including the header files, and the compilation of your
program.</p>
<p>If the prefix is written in capital letters, do <em>not</em> alter it.  The
<code class="docutils literal notranslate"><span class="pre">CHARM_*</span></code> symbols are common across all precisions of CHarm.</p>
</li>
<li><p>In your code, replace every <code class="docutils literal notranslate"><span class="pre">double</span></code> variable entering CHarm functions by
<code class="docutils literal notranslate"><span class="pre">float</span></code> for single precision or by <code class="docutils literal notranslate"><span class="pre">__float128</span></code> for quadruple precision.</p></li>
<li><p>To compile your code in quadruple precision, link the <code class="docutils literal notranslate"><span class="pre">libquadmath</span></code>
library, that is, add <code class="docutils literal notranslate"><span class="pre">-lquadmath</span></code> before <code class="docutils literal notranslate"><span class="pre">-lm</span></code> (see
<a class="reference internal" href="#compilation-linux"><span class="std std-ref">Compilation on Linux</span></a>).</p></li>
<li><p>When compiling your program, use the <code class="docutils literal notranslate"><span class="pre">fftwf*</span></code> or <code class="docutils literal notranslate"><span class="pre">fftwq*</span></code> prefix to
link FFTW in single or quadruple precision, respectively.</p></li>
</ul>
<section id="example-compilation-in-single-precision">
<h3>Example compilation in single precision<a class="headerlink" href="#example-compilation-in-single-precision" title="Link to this heading">#</a></h3>
<p>Assuming your working directory is <code class="docutils literal notranslate"><span class="pre">cookbook/c</span></code>, an example compilation
with the static library might look like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-fopenmp<span class="w"> </span>shcsf.c<span class="w"> </span>-l:libcharmf.a<span class="w"> </span>-lfftw3f<span class="w"> </span>-lfftw3f_omp<span class="w"> </span>-lm
</pre></div>
</div>
<p>Compilation with the shared library:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-fopenmp<span class="w"> </span>-Wl,-rpath<span class="w"> </span>-Wl,/usr/local/lib<span class="w"> </span>shcsf.c<span class="w"> </span><span class="se">\</span>
<span class="w">     </span>-lcharmf<span class="w"> </span>-lfftw3f<span class="w"> </span>-lfftw3f_omp<span class="w"> </span>-lm
</pre></div>
</div>
</section>
<section id="example-compilation-in-quadruple-precision">
<h3>Example compilation in quadruple precision<a class="headerlink" href="#example-compilation-in-quadruple-precision" title="Link to this heading">#</a></h3>
<p>Static library:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-fopenmp<span class="w"> </span>shcsq.c<span class="w"> </span>-l:libcharmq.a<span class="w"> </span>-lfftw3q<span class="w"> </span>-lfftw3q_omp<span class="w"> </span><span class="se">\</span>
<span class="w">     </span>-lquadmath<span class="w"> </span>-lm
</pre></div>
</div>
<p>Shared library:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-fopenmp<span class="w"> </span>-Wl,-rpath<span class="w"> </span>-Wl,/usr/local/lib<span class="w"> </span>shcsq.c<span class="w"> </span><span class="se">\</span>
<span class="w">     </span>-lcharmq<span class="w"> </span>-lfftw3q<span class="w"> </span>-lfftw3q_omp<span class="w"> </span>-lquadmath<span class="w"> </span>-lm
</pre></div>
</div>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="cookbook.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Cookbook</p>
      </div>
    </a>
    <a class="right-next"
       href="cookbook-py.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">PyHarm</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#charm-in-double-precision">CHarm in double precision</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compilation-on-linux">Compilation on Linux</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#working-with-spherical-harmonic-coefficients">Working with spherical harmonic coefficients</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spherical-harmonic-synthesis-and-analysis">Spherical harmonic synthesis and analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#first-and-second-order-gradients-gravitational-vector-and-tensor">First- and second-order gradients (gravitational vector and tensor)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gravity-forward-modelling">Gravity forward modelling</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fourier-coefficients-of-legendre-functions">Fourier coefficients of Legendre functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#integrals">Integrals</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#distributed-computing-with-mpi">Distributed computing with MPI</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#charm-in-single-and-quadruple-precision">CHarm in single and quadruple precision</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-compilation-in-single-precision">Example compilation in single precision</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-compilation-in-quadruple-precision">Example compilation in quadruple precision</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Blaej Bucha
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2025, Blaej Bucha.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    <p class="last-updated">
  Last updated on Jul 18, 2025.
  <br/>
</p>
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>